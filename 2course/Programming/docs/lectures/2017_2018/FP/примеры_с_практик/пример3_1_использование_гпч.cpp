/*
    Пример применения генератора псевдослучайных чисел (ГПЧ) из
    стандартной библиотеки C++
*/

#include <iostream>
#include <ctime>  // Библиотека работы со временем
#include <random> // Библиотека с различными генераторами

using namespace std;

/*
    Функция для получения действительного случайного числа,
    равномерно распределённого в диапазоне [0.0; 1.0].

    Пока только объявление.
*/
double real_rnd_0_1();

/*
    Функция для получнния случайного действительного числа
    в интервале [a; b]. Значения правого и левого краёв 
    передаются через 2 аргумента. Внутри используется функция
    real_rnd_0_1
*/
double real_rnd_a_b(double a, double b);

int main()
{
    /*
        Используем тип mt19937_64 для создания переменной,
        которая и будет создавать случайные числа.

        При создании переменной-генератора ей передаётся
        количество секунд, прошедших с 01.01.1970 00:00:00,
        которое используется в качестве зерна ГПЧ. Это число
        возращается функцией time, определённой в <ctime>.
        Данная функция ожидает адрес некоторой библиотечной
        структуры, но вместо него можно передать и специальный
        нулевой адрес. Этот нулевой адрес представлен ключевым
        словом - nullptr
    */
    mt19937_64 gnr( time(nullptr) );

    /*
        Случайное число создаётся с помощью вызова специального оператора -
        пары круглых скобок. Очень похоже на вызов функции, но применяется
        к переменным некоторых составных (сложных) типов данных.

        Каждое случайное число является беззнаковым целым из
        диапазона [0; MAX], где MAX - величина относящаяся
        к алгоритму ГПЧ. Случайные числа выбираются из указанного
        интервала равномерно.
    */
    cout << "Случайное число: " << gnr() << "\n";
    cout << "ещё одно: " << gnr() << "\n";

    // Получить максимально возможное случайно число:
    cout << "Максимальное число, доступное ГПЧ: " << gnr.max() << "\n";

    cout << "Случайное число от 0 до 1: " << real_rnd_0_1() << "\n";

    // Пример заполнения статического массива числами из заданного интервала: [-1.5; 7.8]
    double arr_2D[11][7];
    for (unsigned i = 0; i < 11; ++i) {
        for (unsigned j = 0; j < 7; ++j) {
            arr_2D[i][j] = real_rnd_a_b(-1.5, 7.8);
        }
    }

    cout << "Созданный массив:\n";
    // Используем специальный цикл for (for-range) для печати элементов
    // двумерного массива
    for (const auto& row : arr_2D) { // Этот цикл переберает все строчки
        for (double elem : row) {    // Этот - все элементы в конкретной строке
            cout << elem << " ";
        }
        cout << "\n";
    }
    cout << "\n";
}

double real_rnd_0_1()
{
    /*
        Пример статической переменной: данная переменная создаётся
        при начале работы программы один раз и не меняется/удаляется
        при любом количестве вызовов данной функции.
    */
    static mt19937_64 gener( time(nullptr) );
    static unsigned long long max_num = gener.max();

    /*
        Что ниже происходит?

        gener() - возращает целое число, max_num - тоже целое.
        Для того, чтобы результат деления был действительным,
        а не целочисленным (при таком делении результат выражения - 
        всегда нуль), нужно сделать явное приведение хотя бы
        одного целочисленного значения к действительному типу данных.

        Это делайтся в C++ с помощью специального оператора: static_cast.
        Он работает следующим образом: в треугольных скобках указан тип,
        к которому нужно привести значение, в круглых скобках - само значение.

        После его выполнения, деление проходит по правилам действительных чисел
        и мы получаем число от 0.0 до 1.0.

        Дополнение: альтернативным способом для задания явного приведения между
        численными типами данных является следующий синтаксис:

            double( gener() )

        , где указывается тип данных, к которому нужно привести значение, а затем
        - само значение.
    */
    return static_cast<double>( gener() ) / max_num;
}

double real_rnd_a_b(double a, double b)
{
    return (b - a) * real_rnd_0_1() + a;
}
