/*
    Пример копирования файла через промежуточный буфер.

*/
#include <stdio.h>
#include <stdlib.h>


int main(void)
{
    /*
        Для создания поток ввода вывода используется специальная структура - FILE (определённая в stdio.h) - 
        и функция fopen:
            FILE* fopen(const char file_name, const char mode)
        , где 
            file_name - строка с именем/путём к файлу;
            mode - специальная строка, значениями которой могут являться:
                "r", "rb": создание потока ввода для чтения информации из файла. Файл должен существовать
                "w", "wb": создание потока вывода для записи информации в файл. Создаётся новый файл 
                           или удаляется всё содержимое существующего
                "a", "ab": создание потока вывода для записи в конец существующего файла. Если не существует 
                           - будет создна новый
                       b - означает открытие файла в двоичном (бинарном) режиме.

                "r+", "rb+": создание потока для одновременного ввода/вывода. Файл должен существовать, 
                             выводить данные можно в любое место в файле
                "w+", "wb+": одновременный ввод/вывод. Создаётся новый файл, либо удаляется содержимое существующего
                "a+", "ab+": одновременный ввод/вывод, но операции вывода осуществляются только в конец файла 

         Функция возращает указатель на объект типа FILE, или NULL в случае, когда поток не может быть создан.

        Общий шаблон для создания потока:
        FILE *my_stream = fopen("some_file_to_open", mode);
        if (my_stream != NULL) {
            //... Операции с потоком
        }
    */

    // Файл из которого копируем
    const char source[] = "input.txt";
    FILE *in_stream = fopen(source, "rb");

    if (in_stream != NULL) {
        // Файл, куда копируем
        const char dest[] = "output.txt";
        // Создание потока вывода
        FILE  *out_stream = fopen(dest, "wb");

        if (out_stream != NULL) {
            /*
                Один из способов узнать размер файла
            */
            fseek(in_stream, 0, SEEK_END); // перемещаем указатель файла в конец
            long int file_size = ftell(in_stream); // получаем размер файла в байтах
            fseek(in_stream, 0, SEEK_SET); // возращаем указатель файла в начало

            char *buff = (char *) malloc(file_size * sizeof(char));
            if (buff != NULL) {    
                char symbol;
                /*
                    Используем функцию fread для неформатированной записи всего содердимого
                    файла *source* в массив *buff*.

                    И функцию fwrite для записи буфера в файл *dest*
                */        
                fread(buff, sizeof(char), file_size, in_stream);
                fwrite(buff, sizeof(char), file_size, out_stream);
            } else {
                perror("Ошибка выделения памяти");
            }

            fclose(out_stream);
        } else {
            perror("Ошибка создания потока вывода");
        }
        
        fclose(in_stream);
    } else {
        perror("Ошибка создания потока ввода");
    }

    return 0;
}
