/*
    Пример чтения конфигурации из файла.
    Подобный код приводился в одной их лекций, но
    пусть будет и в виде законченной программы-примера.

    Для реальных вычислительных задач, ввод начальных данных
    для работы программы с экрана не является оптимальным решением.
    Одним из решений является создание некоторого файла, из которого
    программа будет брать начальные значения. Так, однажды скомпилировав,
    её можно запускать для различных конфигураций.

    Для создания и чтения такого файла нужно продумать его формат.
    Примером может служить файл со следующим содержимым:

        Максимальное число итераций:   60000
        Длина слоя:                    52
        Ширина слоя:                   100
        Количество слоёв:              100
        Сила трения между слоями:      -7.8

    Особенности конфигурации:
        * описания конкретного парамера;
        * каждое описание обязательно заканчивается двоеточием;
        * программе нужны только значения, описания параметров её не интересуют

    Рядом с примером лежит версия на C, которая может быть без проблем
    использована в C++. 
    
    Далее приводится пример разбора файла для получения конфигурации
    с учётом стандартной библиотеки ввода-вывода языка C++.
*/

#include <iostream>
#include <fstream>
#include <limits>
#include <string>

using namespace std;

/*
    Структура, соответствующая ожидаемой конфигурации
*/
struct Config 
{
    size_t max_iter, lx, ly, lz;
    double fric_force;
};

/*
    Перечисление, показывающее, был ли разбор успешен
*/
enum class ParseStatus { 
    SUCCESS, PARSE_ERROR, FILE_ERROR
};

/*
    Функция для чтения конфигурации из файла.
    Принимает два параметра:
        * строку с именем файла
        * ссылку на переменную структуры Config, для сохранения параметров разбора

    Возращает:
        * значение из перечисления ParseStatus (выполнен разбор или нет)
*/
ParseStatus load_config(const string& file_name, Config& params_ptr)
{
    
    ifstream cfg_stream{file_name};
    // Связать поток с файлом не удалось => возращаем константу-индикатор об ошибке
    if ( !cfg_stream.is_open() ) {
        return ParseStatus::FILE_ERROR;
    }

    /*
        Для пропуска строки-описания используется метод: in_stream.ignore(count, delimiter).
        Он принимает два аргумента:
            * count - количество символов для пропуска (не будут участвовать в операциях чтения);
            * delimiter - символ-разделитель (ожидается значение типа char).
        Пропуск прекращается либо после извлечения count символов из потока, либо
        когда попался символ-разделитель (но он тоже извлекается и не учавствует
        в дальнейших операциях чтения).

        Формально count имеет тип std::streamsize, это псевдоним одного из знаковых 
        целочисленных типов (int, long, long long), определённый в стандартной библиотеке
        ввода-вывода C++. Для каждого числового типа данных можно узнать максимальное
        и минимальное значения с помощью библиотеки <limits>. Общая форма:
            numerical_limits<название_типа>::max();
            numerical_limits<название_типа>::min().
        Если метод ignore принимает значение count, равное numerical_limits<streamsize>::max(),
        то он "понимает", что нужно извлекать символы из потока до тех пор, пока не
        встретится символ разделитель. Что идеально подходит под задачу
        разбора - не надо задумываться, какой длины будет строка-описание
        каждого параметра.

        Далее по количеству параметров происходит следующий разбор:
        пропускаем символы до нахождения двоеточия, затем считываем числовой параметр.
    */
    cfg_stream.ignore(numeric_limits<streamsize>::max(), ':');
    cfg_stream >> params_ptr.max_iter;
    // Аналогично - получение остальных числовых параметров
    cfg_stream.ignore(numeric_limits<streamsize>::max(), ':');
    cfg_stream >> params_ptr.lx;
    cfg_stream.ignore(numeric_limits<streamsize>::max(), ':');
    cfg_stream >> params_ptr.ly;
    cfg_stream.ignore(numeric_limits<streamsize>::max(), ':');
    cfg_stream >> params_ptr.lz;
    cfg_stream.ignore(numeric_limits<streamsize>::max(), ':');
    cfg_stream >> params_ptr.fric_force;

    /*
        Одна из операций ввода завершилась с ошибкой,
        возращаем соответствующую константу.
    */
    if ( cfg_stream.fail() ) {
        return ParseStatus::PARSE_ERROR;
    }

    return ParseStatus::SUCCESS;
}

int main()
{
    string file_name;
    cout << "Введите название конфигурационного файла: ";
    getline(cin, file_name);

    Config params;
    const ParseStatus st = load_config(file_name, params);
    // Проверяем - был ли разбор конфигурационного файла успешен
    switch (st) {
        case ParseStatus::FILE_ERROR:
            cerr << "Невозможно открыть файл";
            exit(1);
        case ParseStatus::PARSE_ERROR:
            cerr << "Ошибка разбора параметров конфигурации";
            exit(1);
    }

    cout << "Загруженная конфигурация:"
         << "\n  Количество итераций:    " << params.max_iter
         << "\n  Длина слоя:             " << params.lx
         << "\n  Ширина слоя:            " << params.ly
         << "\n  Количество слоёв:       " << params.lz
         << "\n  Межслоевая сила трения: " << params.fric_force << '\n';
}

