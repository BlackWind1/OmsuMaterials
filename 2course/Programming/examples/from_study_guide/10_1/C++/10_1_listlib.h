/*
    Ниже используемые директивы препроцессора нужны для того, чтобы
    гарантировать то, что функции/переменные/структуры/классы из конкретной
    библиотеки будут объявлены только один раз. Здесь:
        #ifndef 10_1_LISTLIB - проверяет, не было ли объявления идентификатора "10_1_LISTLIB"

        #define 10_1_LISTLIB - объявлем идентификатор "10_1_LISTLIB"

        #endif - закрытие директивы "#ifndef"

*/
#ifndef LISTLIB_10_1
#define LISTLIB_10_1

#include <iostream>
#include <cstring>

/*
    Заодно заключим библиотеку в собственное пространство имён.
*/
namespace listlib {

    struct Cell {
        char *p_str;
        int length;
        /*
            Объявляется указатель на структуру своего же типа.
            В отличии от языка C, в С++ нет необходимости указывать длинное объявление типа.
            В C такой указатель нужно объявлять с использованием *struct*:
                struct Cell *next;

            В тоже время, в C++ тоже можно указывать полное определение.
        */
        Cell *next;
    };

    // Одно отличие по сравнению с пособием: в C++ не надо явно указывать void для функции,
    // которая не принимает никаких аргументов.
    Cell* create_cell();
    Cell* insert_to_list(Cell*, Cell*);
    // И не забываем, что при объявлении функции имя аргумента указывать не обязательно
    void print_list(Cell*);
    void clear_list(Cell*);
};

#endif

