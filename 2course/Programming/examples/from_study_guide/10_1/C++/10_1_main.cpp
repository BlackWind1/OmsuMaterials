/*
    Упорядочить по длине строки, читаемые из стандартного входного потока.
    Вывести их на печать в порядке увеличения длины.
    Для решения задачи использовать односвязный динамический список.

    Если кратко, то односвязный списов представляет собой набор элементов, в котором у каждого из них содержится ссылка на следующий. 
    Графически можно представить в следующем виде:

        [value1] -> [value2] -> [value3] -> [value4] -> [value5] -> ...

    Здесь под "valueX" - понимается какой-то набор данных, которые нужно хранить (встроенные типы данных, структуры и прочая).
    Для работы со списком в самом простом случае достаточно хранить указатель, который будет указывать на его начало:

        [value1] -> [value2] -> [value3] -> [value4] -> [value5] -> ...
        ^
        |
      list_ptr
    и затем просто проходить по всем элемента до конца, используя ссылки.

    Вставка узлов зависит от требуемого действия и может быть реализована в любое место списка.

    В C++ (да и С) узел списка удобно представлять в виде структуры, содержащей указатель на саму себя:
        struct Node {
            // тут объявляются поля для данных

            Node *next; // указатель на следующий элемент списка.
        };


    *Отличие от пособия*:
        -> используется C++ вместо C
        -> функции для работы со списком выделены в отдельную библиотеку

    Скомпилировать можно либо путём добавления всех файлов в проект CodeBlocks.
    Либо используя окно командной строки (cmd.exe в Windows).

    Для второго способа необходимо:
        - открыть командную строку;
        - узнать полный путь к компилятору (например: "C:\Program Files (x86)\CodeBlocks\MinGW\bin\mingw32-g++.exe" - при дефолтной установке CodeBlocks)
        - перейти к директории с исходными файлами
        - ввести команду вида:
            "C:\Program Files (x86)\CodeBlocks\MinGW\bin\mingw32-g++.exe" -std=c++11 -o 10_1.exe 10_1_main.cpp 10_1_listlib.cpp
            
            * в Linux дистрибутивах проще:
            g++ -std=c++11 -o 10_1.ex 10_1_main.cpp 10_1_listlib.cpp
*/

#include <iostream>
#include <clocale>

#include "10_1_listlib.h"

using namespace std;
using namespace listlib; // используем собственное пространство имён


int main()
{
    setlocale(LC_ALL, "RUS");

    Cell *cell_list = nullptr, *new_cell;

    cout << "Введите строки для списка (пустая строка будет означать конец ввода)" << endl;

    while (true) {
        // можно функции из самописной библиотеки 10_1_listlib вызывать и по полному имени
        new_cell = listlib::create_cell();
        if (new_cell == nullptr)
            break;

        // а можно и без префикса вследствии подключения пространства имён в строке 54 
        cell_list = insert_to_list(cell_list, new_cell);
    }

    cout << "Печатаем список:" << endl;
    print_list(cell_list);

    // Удаление всех узлов списка
    clear_list(cell_list);
    return 0;
}
