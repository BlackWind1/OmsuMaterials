// Пример программы на языке C++. 
// Это комментарий - текст, который не будет никаким образом обработан компилятором
// В данной строке и выше приведён пример однострочного комментария - компилятором пропускается весь текст, начиная с двух слешей и до её переноса.

/*
Пример многострочного комментария. Пропускается весь текст между символами "прямой слеш + звёздочка" и "звёздочка + прямой слеш".
Полезен для развёрнутого описания блока кода (функция, условие ветвления, хитрый цикл).
Также позволяет быстро закоментировать кусок кода, который не нужен в данный момент, но может потребоваться в дальнейшем.
*/

/*
    Подключение внешних библиотек.
    Файлы с расширением ".h" называются заголовочными, и, как правило, включают в себя объявления всех предоставляемых функций, констант и структур данных.
    В данном случае подключаются три библиотеки:
        iostream     - предоставляет функции ввода / вывода как на экран, так и в отдельный файл (printf, scanf, fopen, ...);
        
        сstdlib    - набор полезных функций, включающий в себя функции преобразования строки в число, создание случайного числа и некоторые другие;
        cmath      - набор математических функций из стандартной библиотеки языка С: sin / cos / abs / sqrt и другие.
    Стоит отметить, что большинство стандартных библиотек C доступны в C++ через вызов #include без ".h" и с буквой 'c' вначале. Как пример, 
    cstdlib, cstddef, cstring, cmath и другие. 
*/
#include <iostream>
#include <cstdlib>
#include <cmath>

/*
    Объявление переменных. 
    Под каждую переменную компилятор выделяет память размером, равным размеру типа данных. 
    Общая форма объявления следующая:
        [идентификаторы доступа] <тип_переменной> имя_переменной1, имя_переменной2, имя_переменной3 = значение, ...;
    где [идентификаторы доступа] - специальные директивы компилятору, необязательные для указания;

        <тип_переменной>         - обязателен. Базовые типы данных следующие:
            целочисленные:  short, int, long, long long (к каждому может быть добавлено ключевое слово unsigned для обозначения типа, хранящего только положительные числа)
            действительные: float, double, long double
            символ:         char (зависит от того, как тип char представлен в компиляторе. Как правило, как минимум все символы из таблицы ASCII
                            могут храниться в переменных данного типа).

    Одновременно с объявлением переменной, может быть сделано указание её начального значения.
    В С++ есть три способа присвоить переменной начальное значение: 
        1) int var1 = 0; // Аналогично языку С
        2) int var2(2);  // Такой синтаксис допустим, но не рекоммендуется к использованию в настоящий момент. Предпочтительнее третий вариант 
        3) int var3{5};  // Синтаксис допустим начиная со стандарта С++ 2011 года (C++11). Как правило, самые распостраннёные компиляторы начиная с 2013/2014 года 
                         // имеют полную поддержку поддержку этого стандарта.

    Также переменная может быть объявлена неизменяемой с помощью ключевого слова const.

    Переменные, объявленные вне функций являются глобальными в данном файле и доступны во всех функциях, определённых после.
*/
int function_call_counter = 0, global_number{5}; // объявлять и не использовать переменные - очень плохая практика!!!
const float number_PI = 3.1415926535; // эту переменную нигде ниже нельзя будет изменить.


/*
    Определение функций в общем виде можно представить следующей схемой:
        <возращаемый_тип> имя_функции(список_аргументов)
        {
            тело функции
        }

    Здесь:
        <возращаемый_тип>   - любой встроенный (int, double, char, ...) или пользовательский (struct или enum) тип
                            Необходимо, чтобы функция вернула значение указанного в конструкции "return возращаемое_значение;".
                            
    
        список_аргументов   - тип и имя переменных, перечисляются через запятую. Например: 
            double func1(int a, double b)
            {
                ...
            }

        
        тело_функции        - переменные и нужные инструкции для получения задуманного результата.

    Кроме того, перед возращаемым типом могут идти различные опции компилятора.
    Ниже представлен пример.
*/
double calculate_discriminant(double a, double b, double c)
{
    // a, b и c - три переменные, содержащии копии переданных в функцию значений.

    // Переменная result - локальная, её область видимости - только данная функция, никакая другая не может обратиться к ней.
    // Функция pow - библиотечная функция из сmath, возводящая число (первый аргумент - число, второй - степень)
    double result = std::pow(b, 2) - 4 * a * c;

    // Возращение результата вычисления, совпадающего по типу с возращаемым значением.
    return result;
}

/*
    В отличии от С, в С++ появилась возможность группировать переменные и функции под одним произвольным идентификатором.
    Такую группировку назвали *пространством имён*. Определяется оно с помощью ключевого слова *namespace* и блока кода,
    заключённого в фигурные скобки {}:
        namespace test_nm {
            const int size = 12;

            int get_random() {
                return 3;
            }
        }
    Функции, переменные, константы из пространства имён могут быть использованы с применением оператора "::":
        int new_var = test_nm::size;
        test_nm::get_random();
    
    Функциям и переменным из некоторого пространства имён можно повысить область видимости, используя оператор *using*
        using test_nm::get_random;
        // после этой строки можно делать вызов функции get_random без явного указания пространства имён.
        get_random(); 

    А можно одной командой сделать видимыми все функции из некоторого namespece:
        using namespace test_nm;
        
        // тут доступны и size, и get_random из test_nm

    Эти базовые сведения преведены потому, что вся стандартная библиотека С++ помещена в пространоство имён std. А также и
    стандартныя библиотека из С. Так, выше используется функция std::pow из заголовочного файлы <cmath>.

    Чтобы функции стандартной библиотеки были доступны без явного указания области видимости, стоит использовать *using*:
        using namespace std;
    Что и указывается в первой строчке после данного комментария.
*/
using namespace std;

/*
    Ниже представлен пример *объявления* функции со специальным возращаемым типом - void.
    Данный тип говорит о том, что функция не возращает никакого значения. В некоторых языках функции такого типа называются процедурами.
    
    Кроме того, функция может не принимать никаких аргументов.
    После объявления тело функции может быть определено в другом месте, в том числе другом файле.
*/
void print_data_size();



/*
    Точка входа в программу. Для исполняемых файлов наличие данной функции является обязательной в языке С.
*/
int main()
{
    double a, b, c, discriminant;
    double x1, x2;

    // вызов ранее объявленной функции, круглые скобки - обязательны.
    print_data_size();

    /*
        Для печати строки в стандартный поток вывода (обычно - консоль/командная строка) используется специальная
        переменная *cout*. Она определена в стандратной библиотеке С++ в <iostream>.
        
        Способом отправить строку на печать является оператор: << . Пример:
            cout << "Hello word"; // просто печатаем строку.
            cout << 5;            // целое число
            cout << 6.78;         // число с плавающей точкой
            cout << 'e';          // печатается один символ (в одинарных кавычках нельзя поместить более одного символа)

            cout << 5 << " --- " << 6.5; // вызовы оператора << можно объединять в одной строке.
                      

        Вывод строк (последовательность символов в двойных кавычках) или симолов (знак в одинарных кавычках) может включать в себя слэш-последовательности, 
        которые влияют на показ содержимого в консоли. Некоторые из них: \n - означает перенос строки, \t - вставку символа табуляции, \a - подача звукового сигнала
        в момент вывода.

        Полное определение cout:
            std::cout

        Ниже выводится строка, в конце которой идёт символ пехода на новую строчку - '\n'. В С++ в <iostream> определена специальная
        переменная для этого действия - std::endl (расшифровывается как end line).
    */
    cout << "Program to solve quadratic equation a * x^2 + b * x + c = 0\n";
    /*
        C поморщью endl выше указанную строку можно записать как:
          cout << "Program to solve quadratic equation a * x^2 + b * x + c = 0" << endl;

        endl - вставляет корректный символ окончания строки для конкретной операционной системы. Так, в Windows символом конца строки
        считается пара "\n\r", где второй символ - '\r' - так называемый возврат каретки в командной строке.
    */
    
    cout << "Enter the a, b and c (space is delimeter): ";
    /*
        Для получения значений от пользователя используется переменная cin, 
        связанная со стандартным потоком ввода и оператор: >>. Определена в <iostream>.

        Пример:
            int count;
            cin >> count; // получить от пользователя целое число
        
        Рабоатет следующим образом:
        При вызове оператора >> идёт ожидание пользовательского ввода. По нажатию клавиши Enter происходит просмотр введённой строки.
        Если строка - пустая или не содержит ничего, кроме пробелов - ожидается ввод следующей строки.
        Если в строке были символы, то они делятся на группы и происходит попытка заполнить нужные переменные. Разделение на группы
        происходит по пробельному символу. Заполнение переменных осуществляется через попытку преобразования символов в требуемый тип данных,
        определяемый типом переменной count. На примерах:
            если пользователь введёт 5 пробелов - "    "  - и нажмёт Enter, то программа ждёт ввода следующей строки
            если пользователь введёт строку вида "456" - то это число запишется в переменную count
            
            если пользователь введёт строку вида "4 5678" - то в переменную count будет записано число 4, а набор символов "5678" будет 
                                                            ожидать следующего вызова оператора >> для cin
                                                            int another_int_var;
                                                            cin >> another_int_var; // здесь в переменную another_int_var попадёт число 5678
                                                                                    // без необходимости нового ввода с клавиатуры.

            если будут введены некоторые символы, не являющиеся цифрами - "asv" - в переменную count не будет записано ни какого значения.

        Как можно заметить, в отличие от языка С - не надо в явном виде указывать ни ожидаемый тип данных, ни адрес конкретной переменной 
    */
    cin >> a >> b >> c; // Можно вводить как по одному числу, так и три сразу, но разделённые пробелами.

    // Вызов функции
    discriminant = calculate_discriminant(a, b, c);

    if ( discriminant > 0 ) {
        x1 = ( -b + sqrt( discriminant ) ) / 2 * c;
        x2 = ( -b - sqrt( discriminant ) ) / 2 * c;
        
        cout << "x1 is: " << x1 << endl;
        cout << "x2 is: " << x2 << endl;
    } else {
        cout << "The equation has no real roots" << endl;
    }
    
    return 0;
}

// Определяем тело функции print_data_size, которая была объявлена выше.
void print_data_size()
{
    /*
        Конструкция sizeof(...) - является встроенным оператором языка С++, вычисляющим размер памяти (в байтах), 
        выделяемой для аргумента этого оператора. Если в качестве аргумента указан тип (а не переменная), то возращается размер, 
        который будет выделен под каждую переменную данного типа.
    */
    cout << "Size of short: " << sizeof(short) << endl;
    cout << "Size of int: " << sizeof(int) << endl;
    cout << "Size of long int: " << sizeof(long) << endl;
    cout << "Size of unsigned int: " << sizeof(unsigned int) << endl;

    cout << "Size of float: " << sizeof(float) << endl << "Size of double: " <<  sizeof(double) << endl;
    cout << "Size of long double: " << sizeof(long double) << endl;

    // Пример обращения к глобальной переменной number_PI, определённой выше
    cout << "Global variable PI is " << number_PI << endl;
    
    // Можно выйти из функции и указанием явного return без возращаемого значения (Использовать только для функций с возращаемым типом void). 
    // Обязательным не является и применяется в случаях сложного ветвления логики выполнения. Потому и закомментирована. 
    // return;
}
