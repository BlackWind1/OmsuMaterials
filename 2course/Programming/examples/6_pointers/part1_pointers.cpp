/*
    Основной материал по основам указателей в C/C++ расположен по адресу: https://github.com/posgen/OmsuMaterials/wiki/Variables-and-ponters:-basic

    Данная программа аналогична по содержанию файлу part1_pointers.c, за исключением ввода-вывода

    В данной программе рассмотрены некоторые примеры, касающиеся указателей.

    Указатель сам по себе - это тип данных, переменные которого хранят в себе некоторый адрес в памяти. Как и
    обычные переменные, указатели являются типизированными: необходимо указывать конкретный тип указателя для корректной
    работы с ним. Объявляется переменная-указатель с помощью символа '*':
        int *p_int; // p_int - это переменная-указатель (для красткости, далее - просто указатель) на тип int
        double *p_dbl; // P_dbl - указатель на тип double

    После объявления переменных для работы с указателем ему обязательно нужно присвоить значение:
        // НИКОГДА так не делайте, до того, как присвоили указателю конкретное значение
        // cout << *p_dbl; // пытаемся напечатать значение типа double из области памяти,
                                  // адрес которой содержится в переменной p_dbl. "*p_dbl" - называется
                                  // разыменованием указателя.

    Поскольку, указатели содержат адреса, нам нужны в программе переменные, чтобы было у кого эти адреса взять.
    Получение адреса происходит с помощью оператора "&":
        int num1 = 777;
        double num2 = 3.14;

        p_int = &num1; // записываем адрес переменной num1 в переменную p_int.
        p_dbl = &num2; // тоже самое для p_dbl

        // Теперь можно обращаться к значениям переменных через указатели:
        printf("num1 is %d\nnum2 is %lf\n", *p_int, *p_dbl); // Пример разыменования указателей.

        // можно менять значение переменных, адрес которых мы сохранили
        *p_int = 15;
        // теперь и num1 возращает значение 15, а не 777.


    В отличии от переменных, можно объявлять указатель типа void:
        // void var1; -> ОШИБКА, недопустимо так делать.
        void *p_void; // А тут всё хорошо.

    Для подобных указателей разрашена только операция присвоения им любых адресов:
        p_void = &num1;

    Также, указатель на void можно приводить к любому другому типу указателей:
        int *p_int2 = (int *) p_void; // явное приведение типа указателя

    Для указателей на void запрещены операции разыменования и индексации.

*/

#include <iostream>

using namespace std;


int main()
{
    // Пример получения конкретного адреса переменных через указатель
    // Как видно ниже, указатели и обычные переменные могут быть объявлены в одном списке. Звёздочка - * - действует только на
    // конкретную переменную.
    int i_num = 15, *p_int;
    float *p_dbl, f_num = 45.88; // f_num - обычная переменная, а никакой не указатель

    p_int = &i_num;
    p_dbl = &f_num;

    /*
        Печатаем адрес переменных через указатель.
        Тут "%p" в функции printf - это печать конкретного значения указателя (адреса, который он содержит) в шестнадцатиричном формате с префиксом "0x".

        Как видно, сами по себе переменные p_int и p_dbl просто вернут целые числа, которые являются адресами конкретных
        ячеек в памяти.
    */
    cout << "The address of variable i_num is %p" << p_int << endl;
    cout << "The address of variable f_num is %p" << p_dbl << endl;

    // Демонстрация разыменования указателей
    *p_int = 28; // изменяем значение по адресу, который содержит указатель p_int
    cout << "p_int points to value " << *p_int << ", i_num has value: " << i_num << endl; // два напечатанных числа будут совпадать

    *p_dbl = 12.5 + *p_int; // с помощью разыменования, можно использовать указатели и в арифметических выражениях
    cout << "p_dbl points to " << *p_dbl << endl; // напечатает на консоли строку "p_dbl points to 40.5".
                                             // Переменная f_num теперь равна этому же (40.5) числу.

    // Обратная связь тоже работает
    f_num = 5.8;
    cout << "p_dbl points to " << *p_dbl << endl; // печатаем "p_dbl points to 5.8"

    return 0;
}
