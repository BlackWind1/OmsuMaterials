/*
    Желательно ознакомиться с файлами part1_pointers.c и part2_pointers.c в той же директории, что и данный файл.

    Далее демонстрируется пример многомерных динамических массивов.
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>


int main(void)
{
    srand( time(NULL) ); // инициализация генератора псевдослучайных чисел

    // Для объявления многомерного массива надо только указать количество звёздочек, равное его размерности
    // В данном случае объявляется двумерный массив целых чисел
    int **two_dim_array;

    // Далее нужно получить размерности массива. По аналогии с матрицами, обзовём их - числом строк и числом столбцов
    unsigned int rows_count, cols_count;

    puts("Enter cols count: ");
    scanf("%d", &cols_count);

    puts("Enter rows count: ");
    scanf("%d", &rows_count);

    // Затем начинаем выделять требуемую память для сохранения нужного количества элементов
    // Технически, двумерный массив в C состоит из массива указателей, каждый из которых
    // указывает на обычный одномерный массив.
    // Для правильного выделения и использование необходимо корректное приведение результата,
    // который возращает malloc, к типу (int**)
    // Также стоит обратить внимание на оператор sizeof(int*). Здесь нам нужен размер типа "указатель на int,
    // а не просто sizeof(int)
    two_dim_array = (int **) malloc( cols_count * sizeof(int*) );
    if ( two_dim_array == NULL ) {
        // Желательно после каждого выделения памяти проверять, а было ли выделение успешно
        // Делается это путём сравнения указателя с его нулевым значением (NULL - в C)
        perror("Allocation memory error"); // perror - аналогичен printf, но предназначен для вывода сообщений об ошибках
        return -1;
    }

    /*
        Когда всё прошло успешно, был получен массив указателей с числом элементов cols_count
        Теперь каждый элемент two_dim_array[i] сам по себе является обычным одномерным указателем (i изменяется от 0 до cols_count - 1)
        Этот факт можно даже продемонстрировать так:
            int i = 0, *p_int;   // объявляем индекс и обычный указатель на int
            p_int = two_dim_array[i]; // оба значения по сути - аналогичны

        Поэтому теперь каждому указателю two_dim_array[i] может быть выделен блок памяти для хранения конкретных значений
    */
    unsigned int i, j, k;
    for (i = 0; i < cols_count; ++i) {
        two_dim_array[i] = (int *) malloc( rows_count * sizeof(int) );

        // новое выделение динамической памяти => новая проверка на успешность операции
        if ( two_dim_array[i] == NULL ) {
            perror("Allocation memory error");
            return -1;
        }
    }

    /*
        Итак, после всех выделений памяти, у нас имеется массив из cols_count указателей,
        каждый их которых указывате на массив из rows_count целых чисел. На начало всей этой замысловатой структуры
        указывает переменная two_dim_array.

        Каждый указатель можно получить с помощью следующей индексации:
            two_dim_array[2] - третий указатель в их массиве (предполагается, что cols_count > 3)

        К каждому конкретному значению в массиве через двойную индексацию:
            two_dim_array[2][4] - доступ к пятому элементу третьего массива.
        Или на языке матриц, two_dim_array[2][4] - доступ к элемнту, расположенному в 3 строке, 5 столбце
    */

    // Далее заполним two_dim_array случайными числами и выведем на экран в виде матрицы
    puts("The 2D matrix:");
    for (i = 0; i < cols_count; ++i) {
        for (j = 0; j < rows_count; ++j) {
            two_dim_array[i][j] = -15 + (rand() % 22);
            printf("%d\t", two_dim_array[i][j]); // печатаем текущий элемент и вставляем символ табуляции для отделения
                                                 // значений строки друг от друга
        }
        printf("\n"); // переход на новую строчку
    }

    /*
        После работы с динамическим массивом, хорошим тоном является освобождение всей используемой памяти.
        Для двумерного массива, освобождение памяти делается в порядке, обратном выделению:
            - сначало освобождаем для каждого массива
            - затем удаляем все массив указателей
    */
    for (i = 0; i < cols_count; ++i) {
        free(two_dim_array[i]); // действие, обратное строке 55
    }
    free(two_dim_array); // действие, обратное строке 36

    /*
        Далее пример (почти без комментариев) для объявления и заполнения, и какого-никакого,
        а вывода для трёхмерного массива действительных чисел.

        Поскольку третий размер вводить лень, предположим, что первая и вторая размерности равны cols_count,
        а третья - rows_count.

        Для разнообразия, вместо malloc используется calloc
    */
    float ***three_dim_array;
    three_dim_array = (float***) calloc( cols_count, sizeof(int**) );
    if (three_dim_array == NULL) {
        perror("Allocation memory error");
        return -1;
    }

    for (i = 0; i < cols_count; ++i) {
        three_dim_array[i] = (float**) calloc( cols_count, sizeof(int*) );
        if (three_dim_array[i] == NULL) {
            perror("Allocation memory error");
            return -1;
        }

        for (j = 0; j < cols_count; ++j) {
            three_dim_array[i][j] = (float*) calloc( rows_count, sizeof(int) );
            if (three_dim_array[i][j] == NULL) {
                perror("Allocation memory error");
                return -1;
            }
        }
    }
    // тут выделение памяти под 3D массив закончено

    printf("\n3D array:\n");
    for (i = 0; i < cols_count; ++i) {
        printf("%d layer:\n", i + 1);
        for (j = 0; j < cols_count; ++j) {
            for (k = 0; k < rows_count; ++k) {
                three_dim_array[i][j][k] = ((float) rand() ) / RAND_MAX; // случайные действительные числа от 0 до 1
                printf("%f\t", three_dim_array[i][j][k]);
            }
            printf("\n");
        }
    }

    // освобождение памяти для трёхмерного массива
    for (i = 0; i < cols_count; ++i) {
        for (j = 0; j < cols_count; ++j) {
            free(three_dim_array[i][j]);
        }
        free(three_dim_array[i]);
    }
    free(three_dim_array);

    return 0;
}
