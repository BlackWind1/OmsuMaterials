/*
    Переполагается, что просмотрели файл 0_structs.c и осознали, зачем в язык C ввели структуры.

    В С++ также в наличии ключевое слово struct и возможность комбинирования разных типов под одним названием.
    Весь код из 0_structs.c - рабочий и в C++. Разве что, трюк с typedef в язык C++ не нужен. Если мы определили
    структурный тип, то его переменные моэно объявлять без ключевого слова struct:
        struct SomeData
        {
            int num;
            char name[50];
        };

        SomeData sm1, sm2, sm3;
    За сим, оставляем структуры в C++ в покое, к ним вернёмся, но не слишком скоро.

    В C++, в дополнение к процедурной концепции (организация обработки данных через набор функций), были добавлены
    инструменты объектно-ориентированного программирования (далее - ООП). Сам концепция ООП пришла из
    реального мира: человек взаимодействует только с теми или иными объектами (стол, стул, ведро, компьютер,
    автомобиль и прочая, прочая).

    Рассмотрим, простейший объект - некоторая ёмкость. Она имеет характеристики, как минимум вместимость и габариты.
    Они называются состоянием объекта. Например, мы знаем что конкретный экземпляр имеет вместимость 5 литров и,
    скажем, высоту 70 см. Эти числа являются данными, но сами по себе они бесполезны: в чистом виде мы не взаимодействуем
    с состоянием. Вот конкретный объект - другое дело. Но при этом состояние (суть - характеристики) важно,
    когда мы придумываем, что можно сделать с помощью имеющегося объекта.

    Другой пример - кофе-машина. Всё, что о ней надо знать - на какую кнопку нажать для получения конкретного
    напитка. Какое у состояние у кофе-машины (объём жидкости внутри, нагрев воды, количество сортов напитка),
    в общем-то, не интересно. Взаимодействуем с неё только через строго определённые функции.

    По аналогии с такими примерами, в программирование пришла идея, о возможности создания отдельных компонент,
    которые включали в себя как состояние (через набор данных), так и функции для изменения этого состояния.
    Вот примерно там и появилось сама концепция ООП.

    Уже принимая во внимание программирование, для определения и работы с объектами нам нужен тип данных.
    Такой тип данных в C++ (да и в куче других языков) назвали *классом*. Синтаксис объявления класса
    в плюсах следующий:
        class <название_класса>
        {
            ...
        };

    Уже один общий вид должен натолкнуть на мысль, что общее описание сильно похоже на таковое для структур.
    И не зря! Добавление полей класса делается абсолютно аналогично добавлению полей структуры. Например,
        class Coord
        {
            int x, y, z; // данные переменные и сохраняют состояние конкретного объекта
        };

        Coord crd1, crd2; // crd1, crd2 - объекты класса Coord. И да, выше указанного кода достаточно для объявлениря переменных.

    Существенным различием со структурами является то, что по умолчанию доступ к полям x, y и z - запрещён:
        crd1.x = 10; // ОШИБКА!

    Такие поля называют закрытыми (private). Формально, полное определение указанного выше класса такое:
        class Coord
        {
        private:         // метка private ставится по умолчанию, так что можно не указывать её.
            int x, y, z; // данные переменные и сохраняют состояние конкретного объекта
        };

    Далее, раз есть закрытые поля класса, то должны быть и открытые:
        class Coord
        {
            int x, y, z;

        public:                 // необходимо для перечисления открытых полей класса
            unsigned int tm;
        };

        Coord crd3;
        crd3.tm = 2016; // Всё в порядке, допустимая операция с открытым полем
        // crd3.x = 10;    // Внезапно, но до сих пор - ошибка компиляции.

    Блоки с private и public полями могут произвольно чередоваться, например:
        class Coord
        {
           int x;

        public:
            unsigned int tm;

        private:              // начиня со следующей строки, все объявления опять являются закрытыми
            int y, z;
        };

    Вспоминаем пример с кофе-машиной: там говорилось про какие-то функции. Так и для класса: раз имеется
    какое-то состояние, то должна быть добавлена возможность как-то его менять или получать. Делается это
    с помощью объявления функций внутри класса. Причём объявление может быть как в закрытой, так и в открытой
    частях класса:
        class Coord
        {
            int x, y, z;

            void print_x(); // объявление закрытой функции. Если тело функции не пришется здесь же, то точка с запятой - обязательны

        public:
            unsigned int tm;

            int get_x();    // объявление открытых функций
            int get_y();
            int get_z();

            void print();
            void set_coord(int _x, int _y, int _z);
        };

    Внимание: подразумеваем, что функции определены (т.е. написаны тела функций для каждой из них).
    Функции в классе, объявленные выше, называются **методами** класса. Определяются они, как и обычные
    процедурные функции: придумали название, возращаемый тип, количество аргументов и вперёд. Но должны же
    они иметь какую-то особенность, не зря их внутрь класса запизивали?

    И такая особенность есть: методы класса имеют доступ к любым полям класса, как закрытым, так и открытым.
    То есть, в определении функции мы можем оперировать переменными x,y,z, tm - и каждый раз будут использоваться
    значения из конкретного объекта. Чтобы не терять мысль, к примеру:
        class Coord
        {
            int x, y, z;

            void print_x()
            {
                cout << "x is " << x << endl; // обращаемся к полю x
            }   // если тело функции помещено внутрь класса, то точка с запятой в этом месте не нужна.

        public:
            unsigned int tm;

            int get_x()
            { return x; }

            int get_y()
            { return y; }

            int get_z()
            { return z; }

            void print()
            {
                print_x();                          // вызов закрытого метода
                cout << "y is " << y << endl;
                cout << "z is " << z << endl;
                cout << "tm is " << tm << endl;
            }

            void set_coord(int _x, int _y, int _z); // определим эжту функцию вне класса
        };

        // Методы класса не обязательно должны быть определены внутри него
        // Здесь показано, как определять тела методов вне класса
        // В принципе, ничего необычного. Разве что не забывать ставить "<название_класса>" и двоеточие "::"
        void Coord::set_coord(int _x, int _y, int _z)
        {
            x = _x; // меняем поле x у конкретного объекта
            y = _y;
            z = _z;
        }

        // вызов методав класса для конкретного объекта
        Coord crd4;
        crd4.set_coord(1, 4, 5);
        crd4.print();

        int x1 = crd4.get_x();

    Объединение полей и методов в классе (типе данных), как например в Coord выше, называется в ООП - **инкапсуляцией**.

    Пожалуйста, если написанное выше не совсем понятно, или совсем не понятно - сообщайте, будем искать другие слова.

    Далее простой пример для начала работы с классами.
*/

#include <iostream>
#include <cmath>

using namespace std;

/*
    Данный файл - только начала набора программ по ООП, в котором на примере
    последовательной модернизации одного и того же класса будут показаны основные особенности
    объектного программирования в C++.

    Задачу для этого класса сформулируем так: хотим получить класс, описывающий некоторое
    разливочное устройство (резервуар) для жидкости. Основными характеристиками такой штукенции являются:
        * вместимость       - максимальный объём, измеряем в действительных числах
        * текущий уровень   - каков запас жидкости в данный момент. Также измеряется в действительных числах

    А методы класса - будут объяснены ниже. Сам класс будет везде написан по следующему принципу:
        идёт объявления класса (поля + объявления методов), затем функция main, и только после неё
        реализация всех методов класса.
*/
class FillingMachine
{
    double capacity;            // максимальныя вместимость
    double current_volume;      // текущий объём

public:
    // возращает вместимость конкретного объекта
    double get_capacity();

    // проверяем, есть ли жидкость в объекте. Возращаем булево значение (истина / ложь, они же - true / false).
    bool is_empty();
    // обратная проверка - не заполнен ли объект
    bool is_full();

    // снова заполняем наш резервуар до максимальной вместимости
    void restore_full_volume();

    // Установить полную вместимость и заполнить максимальным значением.
    void set_full(double _capacity);


    /*
        Пробуем запросить требуемый объём из резервуара.
        В случае, если запрошенный объём больше текущего количества -
        возращается отрицательное число (как способ обнаружить и обработать ошибку).
    */
    double take_volume(double required_vol);
};

int main()
{
    FillingMachine fm;
    fm.set_full(8.5);

    cout << fm.take_volume(4.5) << endl;

    cout.setf(ios_base::boolalpha);
    cout << fm.is_empty() << endl;
    cout << fm.is_full() << endl;

    double result = fm.take_volume(5.5);
    if (result < 0) {
        cout << "No enough volume at device" << endl;
    }

    cout << fm.is_empty() << endl;
    cout << fm.is_full() << endl;

    return 0;
}

double FillingMachine::get_capacity()
{
    return capacity;
}

bool FillingMachine::is_empty()
{
    return current_volume <= 0;
}

bool FillingMachine::is_full()
{
    if ( current_volume <= 0 ) {
        return false;
    } else {
        return abs(capacity - current_volume) < 0.0000001;
    }
}

void FillingMachine::restore_full_volume()
{
    current_volume = capacity;
}

void FillingMachine::set_full(double _capacity)
{
    current_volume = capacity = _capacity;
}

double FillingMachine::take_volume(double required_vol)
{
    if ( required_vol > current_volume ) {
        return -1.0;
    }

    current_volume -= required_vol;
    return required_vol;
}

