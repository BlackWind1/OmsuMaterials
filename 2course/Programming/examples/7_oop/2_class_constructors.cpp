/*
    !Все файлы с номерами меньше текущего в одной директории - обязательны к прочтению в порядке возрастания номеров!

    В файле 1_class_basics.cpp для установления начальных значений полей класса использовался метод set_full.
    Это нормальная ситуация, можно даже определять по одному методу для каэдого закрытого поля. Однако,
    при значительном количестве полей, или их связности, вызов многих методов для того, чтобы просто
    задать начальное состояние объекта - становится слишком надоедливым. Просто представьте:
        MyClass obj1;

        obj1.set_field1(1);
        obj1.set_field2(1);
        obj1.set_field3(1);
        obj1.set_field4(1);
        obj1.set_field5(1);
        obj1.set_field6(1);

    И всё ради того, чтобы задать начальное состояние для конкретного объекта. Кроме того, для простых типов данных
    все привыкли иметь возможность не просто объявлять переменные, но и тут же присваивать им
    начальные значения:
        int x = 10;
        char symb1 = '*';

    Для возможности так работать и с объектами классов, язык C++ предоставляет концепцию *конструктора*.
    Конструктор - специальный метод класса для задания внутреннего состояния (закрытых полей) объекта класса.
    Особенность конструктора - в некоторых ограничениях:
        -> имя функции всегда совпадает с названием класса;
        -> конструктор не имеет возращаемого значения;
        -> в конструкторе явно не вызывается оператор return.

    Рассмотрим на примере простого (и ничего полезного неделающего класса):
        class TestCl
        {
            int num;
            char symb;

        public:
            // а вот и конструктор
            // Как видно, это обычная функция, но без возращаемого значения
            // Количество аргументов определяем, как и для обычного метода класса -
            // сколько захочем, столько и передадим
            // Так же, как и любой другой метод, конструктор может быть определён вне класса,
            // но для компактности, пусть будет внутри класса
            TestCl(int _num, char _symb)
            {
                num  = _num;
                symb = _symb;
            }

            void change_num(int another) // просто метод для теста
            {
                num += another;
            }

            int get_num()
            {
                return num;
            }
        };

        // Теперь объекты можно определять так:
        TestCl obj1(14, 'f'); // поля num и symb получили значение 14 и 'f'
        cout << obj1.get_num() << endl;

    Но! Как только мы определили хотя бы один конструктор с параметрами пропала возможность
    определять объекты без задания значений через конструктор:
        // TestCl obj2; // Ошибка, пока не скомпилируется

    Это произошло потому, что на самом деле даже для класса в файле 1_class_basics.cpp, в котором
    в явном виде не было никакого конструктора - C++ предоставляет так называемый *конструктор по
    умолчанию*. Его единственная работа заключается в том, чтобы выделить память под все поля класса.
    Такой констуруктор по умолчанию не принимает никаких аргументов. Для выше указанного класса
    его можно добавить так (описания полей и методов - упущены):
        class TestCl
        {
            ...

        public:
            TestCl(int _num, char _symb)
            {
                num  = _num;
                symb = _symb;
            }

            TestCl()
            {}

            ...
        };

    Здесь мы видим, что как и обычные функции в C++, для конструкторов допускается их перегрузка
    (определение функций с одним именем для разного количества/типов аргументов).
    После добавления конструктора по умолчанию, становится возмодность объявлять переменные без
    передачи им значений:
        TestCl obj3; // Теперь компилируется без проблем.

    Кончено, если есть желание, можно в конструкторе по умолчанию установить какие угодно значения полей класса:
        class TestCl
        {
            ...

        public:
            TestCl(int _num, char _symb)
            {
                ...
            }

            TestCl()
            {
                // никто не запрещает делать всё, что вздумается
                // и где вы ещё такую свободу получите то?
                num = 9;
                symb = '+';
            }

            ...
        };

        TestCl obj4; // внутри переменной obj4 значение num равно 9, а symb - '+'

    Опять же, хочет верить, что теперь ясно - конструкторов можно определять сколько угодно,
    с раными аргументами. Констуркторы с параметрами имеют ещё одну особеность синтаксиса - в том
    случае, когда нам тело функции-конструктора не нужно (нет проверки данных на правильность, например).
    Тогда выше указанный конструктор с параметрами можно переписать так:
        class TestCl
        {
            ...

        public:
            // Выражения после двоеточия - называются списком инициализации
            // Так можно делать только для конструкторов, для обычных методов класса - запрещено.
            // Синтаксис ниже верен в том случае, если компилятор поддерживает стандарт языка C++ от 2011 года
            TestCl(int _num, char _symb) : num{_num}, symb{_symb}
            {}
            // А вот старый синтаксис, который также может быть использован. Хотя стоит отдавать
            // предпочтение варианту выше.
            // TestCl(int _num, char _symb) : num(_num), symb(_symb)
            //{}

            ...
        };

    И ещё один интересный факт про конструкторы. Переменные класса, как и простые типы данных
    можно присваивать друг другу. Например:
        TestCl obj5(45, 's'), obj6;
        obj6 = obj5;          // внутренние поля обоих объектов стали одинаковы, но они остаются разными объектами
        obj6.change_num(-3);  // теперь num у obj6 стал равным 42, а для obj5 - остался равным 45.

    В случае такого присвоения вызывается специальный конструктор, называемый конструктором копирования (copy-constructor).
    Они принимает специальный аргумент - другой объект класса, переданный по ссылке. Данный конструктор
    предоставляется для любого написанного класса по умолчанию. Вся его работа заключается в том, чтобы
    создать новый объект класса и скопировать все поля из объекта, указанного справа от знака "=" в новый объект.
    Тут важно - идёт простое копирование, поэтому для специальных полей (указатели, файловый потоки) нужно
    иметь возможность определять конструктор копирования в явном виде.
        class TestCl
        {
            ...

        public:
            // Выражения после двоеточия - называются списком инициализации
            // Так можно делать только для конструкторов, для обычных методов класса - запрещено.
            // Синтаксис ниже верен в том случае, если компилятор поддерживает стандарт языка C++ от 2011 года
            TestCl(int _num, char _symb) : num{_num}, symb{_symb}
            {}

            // Список инициализации может быть использван и в конструкторе по умолчанию
            TestCl() : num{9}, symb{'+'}
            {}

            // А вот и конструктор копирования. И тут используем список инициализации.
            // А вывод строки внутри - просто для демонстрации вывода. Хотя и список
            // инициализации тут не требуется - значения полей и так будут скопированы в новый объект
            TestCl(const TestCl& other) : num{other.num}, symb{other.symb}
            {
                cout << "Copy constructor called" << endl;
            }

            ...
        };

        TestCl obj5(45, 's'), obj6;
        obj6 = obj5;
        obj6.change_num(-3);

    Также, стоит заметить, что конструктор копирования вызывает при передаче переменных класса
    в некоторую функцию
        void print_test_cl(TestCl obj); // при вызове данной функции для конкретной переменной
                                        // будет вызван констуруктор копирования для создания копии объекта

    Ниже класс из файла 1_class_basics.cpp был модернизирован с учётом новых знаний.
*/

#include <iostream>
#include <cmath>

using namespace std;

/*
    Продолжение разработки класса FillingMachine.

    Задача для этого класса была сформулирована так: хотим получить класс, описывающий некоторое
    разливочное устройство (резервуар) для жидкости. Основными характеристиками такой штукенции являются:
        * вместимость       - максимальный объём, измеряем в действительных числах
        * текущий уровень   - каков запас жидкости в данный момент. Также измеряется в действительных числах

    А методы класса - будут объяснены ниже. Сам класс будет везде написан по следующему принципу:
        идёт объявление класса (поля + объявления методов), затем функция main, и только после неё
        реализация всех методов класса.

    Изменения:
        -> удалён метод set_full
        -> добавлены конструкторы
*/
class FillingMachine
{
    double capacity;            // максимальныя вместимость
    double current_volume;      // текущий объём

public:
    FillingMachine(double init_value);
    FillingMachine(const FillingMachine& other);

    // возращает вместимость конкретного объекта
    double get_capacity();

    // проверяем, есть ли жидкость в объекте. Возращаем булево значение (истина / ложь, они же - true / false).
    bool is_empty();
    // обратная проверка - не заполнен ли объект
    bool is_full();

    // снова заполняем наш резервуар до максимальной вместимости
    void restore_full_volume();


    /*
        Пробуем запросить требуемый объём из резервуара.
        В случае, если запрошенный объём больше текущего количества -
        возращается отрицательное число (как способ обнаружить и обработать ошибку).
    */
    double take_volume(double required_vol);
};

int main()
{
    FillingMachine fm1(10), fm2(15.5);
    cout << "take 4.5 volume from fm1 object. The returned value is " << fm1.take_volume(4.5) << endl;

    cout.setf(ios_base::boolalpha);
    cout << "Is fm1 empty: " << fm1.is_empty() << endl;
    cout << "Is fm1 full: " << fm1.is_full() << endl;

    //cout << ld << endl;

    double result = fm1.take_volume(5.5);
    if (result < 0) {
        cout << "No enough volume at device" << endl;
    }

    cout << "Is fm1 empty: " << fm1.is_empty() << endl;
    cout << "Is fm1 full: "<< fm1.is_full() << endl;


    FillingMachine fm3 = fm2;
    fm3.take_volume(15.5);
    cout << "Is fm3 empty: " << fm3.is_empty() << endl;
    cout << "Is fm2 empty: " << fm2.is_empty() << endl;

    return 0;
}

double FillingMachine::get_capacity()
{
    return capacity;
}

bool FillingMachine::is_empty()
{
    return current_volume <= 0;
}

bool FillingMachine::is_full()
{
    if ( current_volume <= 0 ) {
        return false;
    } else {
        return abs(capacity - current_volume) < 0.0000001;
    }
}

void FillingMachine::restore_full_volume()
{
    current_volume = capacity;
}

double FillingMachine::take_volume(double required_vol)
{
    if ( required_vol > current_volume ) {
        return -1.0;
    }

    current_volume -= required_vol;
    return required_vol;
}

/*
    Констурктор с параметром: устанавливаем одновременно и вместимость, и текущее значение объёма.
*/
FillingMachine::FillingMachine(double initial_cap) :
    capacity{initial_cap}, current_volume{initial_cap}
{
    // Вывод только для понимания работы программы, конечно же в нём смысла нет в реальном классе
    cout << "Constructor FillingMachine(double initial_cap) called" << endl;
}

/*
    Констуруктор копирования
*/
FillingMachine::FillingMachine(const FillingMachine& other) : capacity{other.capacity}, current_volume{other.current_volume}
{
    // Вывод только для понимания работы программы, конечно же в нём смысла нет в реальном классе
    cout << "Copy constructor called" << endl;
}
