/*
    Пример использования генератора (псевдо)случайных чисел (ГПСЧ).

    В файле random.cpp расмотрен пример использования ГПСЧ из стандартной библиотеки языка С.
    Для этого вызывались функции srand, rand, а также функция для работы со временем - time.
    Однако, начиная со стандарта C++11, "плюсы" получили свои стандартные библиотеки для работы
    со временем и получения случайных чисел. Например, в отличии от языка С, библиотека случайных
    чисел кроме непосредственно генераторов, предоставляет возможность работы с распределениями
    случайных чисел в нужном диапазоне.

    Для подключения библиотеки работы со временем нужнно написать следующий include:
        #include <chrono>
    , для работы с генераторами случаных чисел:
        #include <random>

    =============================================
    Очень краткое введение в объекты.

    Существенное отличие от библиотеки языка C заключается в том, что в C++ приходится
    иметь дело с объектами, а не простыми переменными и вызовами функций. Объект в C++ по сути
    является переменной некоторого типа данных, для которого допустим вызов некоторого набора функций.
    Этот набор функций ограничен для конкретного типа данных. Рассмотрим на примере.
    Вот есть одна переменная типа int (встроенный или простой тип данных):
        int height = 45;
    Всё, что можем мы с ней делать после объявления, это менять её значение или использовать в других выражениях:
        height += 4;

        int second_height = (height + 4) / 5;

    В последнем выражении, очевидно, вместо height используется хранимое в ней значение. В примере это 49.

    Объекты же - это переменные составного (пользовательского, сложного) типа данных. Вообразите, что в
    языке появился тип данных, представляющих простой прямоугольник - Rectangle. Данная фигура в общем случае
    характеризуется двумя величинами - длиной и высотой. В C++ создание переменной подобного типа выглядит так:
        Rectangle r1(2, 5);

    Допустим, что 2 - это длина, 5 - высота. Для доступа к характеризующим величинам C++ позволяет определить
    специальные функции, которые недоступны в общей области видимости, но могут быть вызваны для конкретной переменной.
    На примере:
        std::cout << r1.get_width() << " ::: " << r1.get_height();

    Здесь на экран выводятся заданные при определении переменной числа. Всё, что надо знать перед рассмотрением
    ГПСЧ, это приведённый в примере синтаксис:
        <переменная>.<некоторая_функция>
    Вернее не то, чтобы знать, в понимать, что такое возможно. А зачем, каким образом и почему - будет рассказано в дальнейших
    примерах. К слову, вызываемые только для переменных определённого типа данных функции получили название *методов объекта*.

    ===============================================================

    Возращаемся к ГПСЧ. В библиотеке <random> определены разные генераторы, их там порядка 10 штук, мы рассмотрим только один:
        std::mt19937_64 (название типа данных)

    Данный генератор называется "вихрем Мерсенна" (англ. Mersenne twister) и отлично подходит для использования в вычислительной физике по таким параметрам, как
    длина создаваемой случайной последовательности и равномерность выборки.

    Большинство генераторов получения случайных чисел представляют собой математический алгоритм получения последовательности:
    x1, x2, x3, ... , xN. После получения числа xN, генератор начинает выдавать последовательность с первого элемента.
    Так под N - понимают период последовательности, и в случае вихря Мерсенна это число составляет примерно (2^19937 − 1).
    Для того, чтобы влиять на получаемую последовательность, обычно ГПСЧ позволяют установить одно или несколько значений,
    используемых в их алгоритмах для получения послеовательности чисел. Такие значения называют *зёрнами генератора*.
    В файле random.cpp для установки зерна стандартного генератора из библиотеки C была использована функция srand.
    При этом, если начать использовать генератор без указания какого-либо значения в качестве зерна, то будет поставлено
    заранее определённое значение по умолчанию. И в этом случае программа при каждом запуске будет выдавать одни и теже
    значения случайных чисел.

    В C++ объявление переменной-генератора происходит так:
        std::mt19937_64 gener1;

    Здесь как раз использовано значение зерна генератора по умолчанию.
    Получаем случайное число целого типа (генератор сам по себе выдаёт только целые неотрицательные числа) так:
        std::cout << "Случайное число: " << gener1() << std::endl;

    Всё действие происходит при указании переменной gener1 и круглых скобок сразу же после неё.
    Сама переменная-объект генератора несёт в себе информацию о максимальном и минимальном значениях:
        std::cout << "Максимальное значение генератора: " << gener1.max() << std::endl;
        std::cout << "Минимальное значение генератора: " << gener1.min() << std::endl;

    Как уже говорилось, приведённый выше код будет выдавать одни и теже числа постоянно при последовательных запусках программы.
    При создании переменной генератора можно указать любое безнаковое целове число в качестве зерна генератора:
        std::mt19937_64 gener2(35664643443);

    Кроме того, повлиять на получаемые случайные число можно и после создания объекта генератора:
        size_t seed = 43553253633388;
        gener1.seed( seed );

    И наконец, чтобы получать разные случайные числа при последовательных запусках программы, можно использовать
    информацию о текущем системном времени. С учётом библиотеки <chrono> в C++ делаем так:
        unsigned long new_seed = std::chrono::system_clock::now().time_since_epoch().count();
        std::mt19937_64 gener2( new_seed );

    Здесь выражение std::chrono::system_clock::now().time_since_epoch().count() означает следующие шаги:
        1) Запросить у ОС текущее время (system_clock::now())
        2) Перевести текущее время в интервал, прошедший с 1 января 1970 00:00:00 (.time_since_epoch())
        3) Перевести интервал времени в целое число, равное количеству секунд, прошедших с выше указанного момента.

    Далее уже смотрим ниже на пример программы и комментарии в ней.
*/

#include <iostream>
#include <clocale>   // Установка локали для вывода в консоли Windows
#include <chrono>    // библиотека С++ для работы со временем
#include <random>    // библиотека C++ для работы со случайными числами

int main()
{
    std::setlocale(LC_ALL, "RUS");

    // Пример использования генератора с параметрами по умолчанию. Вывод будет одинаков при каждом запуске программы
    std::mt19937_64 gener1;
    std::cout << "Три случайных числа от генератора, созданного с зерном по умолчанию\n";
    std::cout << gener1() << "\n" << gener1() << "\n" << gener1() << "\n\n";
    std::cout << "Максимальное значение генератора: " << gener1.max() << std::endl;
    std::cout << "Минимальное значение генератора: " << gener1.min() << std::endl;



    // Пример инициализации генератора случайных чисел значением, зависящим от времени.
    unsigned long time_seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::mt19937_64 gener2( time_seed );
    // Вывод будет отличаться при последовательных запусках программы
    std::cout << "\nТри случайных числа от генератора, созданного с зерном, зависящим от системного времени\n";
    std::cout << gener2() << "\n" << gener2() << "\n" << gener2() << "\n\n";

    /*
        Пара примеров по ограничению получаемых значений.

        В первом будет использовать взятие остатка от деления (оператор %).
        Из математики очевидно, что если проводить взятие остатка от целочисленного деления положительного числа m на
        другое положительное n, то в качестве значений мы можем получить одно из:
            0, 1, 2, 3, ... , n-1
        В самом деле, если вспомнить операции с простыми дробыми, какое бы число не делили на 2, то остаток может быть
        только 0 или 1 (т.е. 3/2 = 1(1/2) ).

        Поэтому ниже приведено получение случайного числа от 0 до 25
    */
    unsigned rnd1 = gener2() % 26;

    // Чтобы получить отрицательное случайное число, нужно заниматься вычитанием
    // Ниже - получение случайного числа от -5 до 5
    int rnd2 = gener2() % 11 - 5;
    /*
        С получением диапазона через оператор % есть нюанс.

        Предположим, что функция rand() возращает следующий ряд из 11 чисел подряд:
            0  1  2  3  4  5  6  7  8  9  10
        А мы хотим получить "псевдослучайные" от нуля до четырёх. Для этого по выше приведённым примерам
        нужно взять остаток от целоичленного деления на 5. Тогда из ряда будут получены результаты:
           (0  1  2  3  4  5  6  7  8  9  10)
            |  |  |  |  |  |  |  |  |  |  |    %5
            v  v  v  v  v  v  v  v  v  v  v
            0  1  2  3  4  0  1  2  3  4  0
        
        Рассматривая последний ряд видно, что вероятность выпадения нуля выше, чем у всех остальных чисел.
        Это означает, что  при использовании оператора % для создания диапазона случайных чисел, нельзя полагать,
        что получаемые в итоге числа в некотором диапазоне равновероятны.

        Отсюда вывод - для учебных и тестовых программ использование оператора взятия остатка от деления особого
        вреда не принесёт, но в реальных задачах (особенно - в численных задачах науки) лучше не использовать его.
    */

    // Для получения действительного числа, следует использовать явное приведение типов.
    // Пример получения числа в диапазоне от 0 до 1:
    double rnd3 = double( gener2() ) / gener2.max();
    /*
        Создание действительного числа в диапазоне [0; 1] позволяет преодолеть недостаток создания значений в
        некотором диапазоне с помощью оператора %. Допустим, есть функция drand_0_1 - которая даёт случайное 
        действительное число в указанном диапазоне. Тогда получить случайные числа на заданном отрезке [a; b]
        можно по формуле:
            a + (b - a) * drand_0_1()
        Из-за особенностей приведения действительных чисел к целым, данная формула верна как для типа int, так и 
        для double.  
    */

    std::cout << "rnd1 = " << rnd1 << ", rnd2 = " << rnd2 << ", rnd3 = " << rnd3<< std::endl;

    /*
        И бонус для тех, кто дошёл до данной строки.

        В <random> кроме самих генераторов случайных чисел, были добавлены различные распределения чисел на
        заданном интервале (равномерное, нормальное, экспонециальное и прочие. Они помогают скрыть расчёты, подобные
        строкам 136 - 144 через некоторый интерфейс. Правда, все распределения в стандартной библиотеке написаны с использованием
        шаблонов. Но никто не мешает запомнить как пользоваться распределениями, а уж как они устроены - понять позже.

        Различные распределения хорошо описаны тут:http://www.cplusplus.com/reference/random/ , раздел "Distributions"

        Ниже расматривается равномерное распределение для случая целых и действительных чисел.
    */
    // Определяем объект распределения на интервале [-10; 20]
    // Здесь немного необычным является указание типа в треугольных скобках, его следует просто запомнить.
    std::uniform_int_distribution<int> int_distrib(-10, 20);
    // Получить конкретное число можно по аналогии с генератором через оператор из пары круглых скобок ()
    // но в эти скобки обязательно должен быть передан генератор. int_distrib.a() - получение левого конца интервала,
    // int_distrib.b() - соответственно, правого
    std::cout << "\nТри случайных целых числа из равномерного распределения от " << int_distrib.a() << " до " << int_distrib.b() << "\n";
    // передаём генератор при каждом получении числа из указанной последовательности
    std::cout << int_distrib( gener2 ) << "\n" << int_distrib( gener2 ) << "\n" << int_distrib( gener2 ) << "\n\n";


    // И пример для действительных чисел
    std::uniform_real_distribution<double> real_distrib(0.5, 3.6);
    std::cout << "Три случайных числа из равномерного распределения от " << real_distrib.a() << " до " << real_distrib.b() << "\n";
    std::cout << real_distrib( gener2 ) << "\n" << real_distrib( gener2 ) << "\n" << real_distrib( gener2 ) << "\n\n";

    // Использовать распределения или писать формулы, подобные строкам 136-144 - исключительно на ваше усмотрение.

    return 0;
}
