/*
    До изучения данныго файла следует заглянуть в strings_c++.cpp.

    Далее приведена справка по некоторым полезным функциям для переменных типа std::string.

    * str.clear() - удаляет все символы для переменной str, оставляя пустую строку. Не
    возращает никакого значения.

      Пример:
        std::string s1 = "Строка!";
        std::cout << "Длина строки: " << s1.length() << '\n';

        s1.clear();
        std::cout << "Длина строки: " << s1.length() << '\n';

    * bool str.empty() - проверяет содержит ли переменная str пустую строку или нет. Функция возращает
    значение типа bool (true или false).

      Пример:
      std::string s1 = "";
      std::cout << "Строка s1 пуста? " << s1.empty();

    * str.insert(pos, another_str) - добавляет строку another_str к строке str, начиная с байта номер pos.
    Как правило, pos это безнаковая целая переменная типа size_t или unsigned. Вставка происходит
    перед символом, которому соответствует число pos. another_str - это либо переменная типа string,
    либо C-строка.

      Пример:
      std::string s1 = "Что-то не так";
      s1.insert(11, " здесь");
      std::cout << s1;

    Что в примере происходит?
    В строку s1 вставляется другая строка, состоящая из пробела и одного слова. Вставка происходит перед
    12 по счёту байтом (выше стоит число 11, потому что индекс в массиве символов, как и в любых других массивах
    начинается с нуля). 12 байт соответствует символу пробела - ' '. В тоже время, до пробела видно всего 5 букв и один знак
    дефиса. Здесь сказывается особенность хранения не-английских алфавитов - каждая буква русского алфавита представлена
    2 байтами. Знак дефиса входит в ASCII-набор и, следовательно, занимает всего 1 байт. Таким образом первые 11 байт
    занимает строка "Что-то" и следующий за ней пробел оказывается в 12 байте (12 по счёту, 11 - если рассматривать массив байт).
    Вызов insert вставляет строку " здесь" прямо перд символом пробела.

    * str.insert(pos1, another_str, pos2, count) - вторая форма функции insert для переменных типа std::string, позволяющая
    вставить в строку str только часть строки another_str. pos1 - перед каким символом будет происходить вставка, pos2 -
    номер байта в строке another_str, начиная с которого в строку str будет вставлено count байт.

      Пример (классика советского школьного английского):
      std::string s1 = "London is capital of Great Britain", s2 = "the cat";
      s1.insert(10, s2, 0, 4); // из s2 только первые 4 символа забираем
      // Печатается "London is the capital of Great Britain"
      std::cout << s1;

    * str.c_str() - возращает строку в стиле C. Функция полезна, если используются функции из стандартной библиотеки
    языка C для работы со строками.

    * string str.substr(start_pos, count = std::string::npos) - создаёт новую строку из str путём выделения count байт,
    начиная с позиции start_pos. По умолчанию count равен специальной константе из типа данных std::string - std::string::npos -
    которая обозначает конец строки.

      Пример:
      std::string s1 = "Помнить факты не значит знать!";
      // Печатаем строку "факты"
      std::cout << s1.substr(15, 10) << '\n';
      // Печатаем "не значит знать!"
      std::cout << s1.substr(26) << '\n';

    * size_t str.find(another_str, pos = 0) - поиск подстроки another_str в строке str. Если строка была найдена, то возращается
    безнаковое целое число - позиция первого байта из строки another_str в строке str. Если не найдена, то возращается значение,
    равное константе std::string::npos. Поиск в строке str начинается с позиции pos. По умолчанию pos равен нулю (то есть - первому байту)
    и поиск идёт с начала str.

      Пример:
      std::string s1 = "Как ваше ничего поживает?";
      size_t pos = s1.find("ва"); // вернёт 7
      std::cout << "первое \"ва\" начинается с позиции: " << pos << '\n';

      pos = s1.find("ва", 15); // Поиск начинается со второго пробела. Вернёт 37
      std::cout << "второе \"ва\" начинается с позиции: " << pos << '\n';

    * size_t str.rfind(another_str, pos = std::string::npos) - поиск подстроки справа налево (с конца строки к её началу).

      Пример:
      std::string s1 = "Как ваше ничего поживает?";
      size_t pos = s1.rfind("ва"); // вернёт 37
      std::cout << "первое \"ва\" от конца строки начинается с позиции: " << pos << '\n';

      pos = s1.rfind("ва", 15); // Поиск начинается со второго пробела. Вернёт 7
      std::cout << "второе \"ва\" от конца строки начинается с позиции: " << pos << '\n';

    * size_t str.find_first_of(another_str, pos = 0) - ищет любой символ из строки another_str (может быть как C-строка, симол в одинарных
    кавычках, или другая переменная  типа std::string). Возращается позиция первого найденного символа, pos - указывает позицию с которой
    начинается поиск. Ключевое словосочетание тут - <<любой символ>>. Поиск идёт посмивольно в терминах переменной типа char. Из-за этого
    данная функция неприменима к работе с русским алфавитом.

      Пример:
      std::string s1 = "This is a string";
      size_t found = s1.find_first_of("aei"); // ищем одну из букв a, e, i
      s1[found] = '#'; // заменяем найденную букву на другой символ
      std::cout << s1 << '\n';

    * size_t str.find_last_of(another, pos = std::String::npos) - аналогично выше, ищется любой символ из another_str, только справа налево (
    и начиная с конца строки).

    Больше методов для переменных типа std::string можно посмотреть тут (правда, на английском): http://www.cplusplus.com/reference/string/string/

    Ниже, несколько примеров указанных выше функций в реальной программе.
*/

#include <iostream>
#include <string>    // тип std::string
#include <clocale>


int main()
{
    std::setlocale(LC_ALL, "RUS");

    std::string s1 = "Быть или не быть. Вот в чём вопрос";
    std::cout << s1.substr(9, 6) << '\n';

    size_t pos = s1.find("или");
    if ( pos != std::string::npos ) {
      std::cout << "\"или\" в строке s1 начинается с позиции: " << pos << '\n';
    }

    pos = s1.find("где", 9);
    if ( pos == std::string::npos ) {
        std::cout << "\"где\" в строке s1 не найдена" << '\n';
    }

    return 0;
}
