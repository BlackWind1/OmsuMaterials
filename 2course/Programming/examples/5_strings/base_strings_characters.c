/*
    В языке С различают символы и строки.

    Символы заключаются в одинарные кавычки
        'a', '8', '&', ' '

    Фактически, каждый символ представляет из себя некоторый знак: буквы, цифра, плюс, минус и прочие.
    Однако, в C некоторые символы состоят из нескольких знаков. Как пример, набор слеш-последовательностей:
        '\n' - символ новой строки. Сам символ - один, но представлен двумя знаками
        '\t' - символ табуляции. Аналогичный случай.

    Для работы с символами в C используется тип *char*
        char symb1 = '4', symb2 = 'a';

    Для вывода символа на консоль или чтения в символьную переменную используется идентификатор - %c
        printf("%c", symb1); // вывести переменную типа char на экран
        scanf("%c", &symb2); // считать первый введённый символ в переменную symb2

    Для получения/вывода символа с/на стандартный поток, дополнительно могут быть использованы следующие 2 функции:
        symb1 = getchar(); // получить символ из stdin
        putchar(symb2);    // вывести символ на stdout

    В языке C каждому символу сопостовляется внутренний код - целое число. Поэтому с переменными
    типа char можно обращаться как с целочисленными величинами. Более того, порядок кодов символов
    неизменен, для примера - смотрите таблицу ASCII кодов в пособии. Из-за этого, символы могут
    принимать участие в арифметических операциях и операциях сравнения:
        char sym = '1';

        sym += 1; // увеличит код символа на 1. В соответствии с таблицей ASCII
                  // в переменной sym будет находится символ двойки: '2';

        if ( sym > '5' ) { // сравниваем символы
            // не выполнится, потому что '2' раньше '5'
        } else {
            printf("Else branch");
        }

        int code = (int) sym; // получение целочисленного кода определённого символа с помощью приведения типов

        if ( sym >= '0' && sym <= '9' ) { // проверяем, что в переменной sym находится символ цифры
            ...
        }

    ************************************************************************************
    Под строкой понимается набор символов, заключённых в двойные кавычки:
        "A simple string"
        "89983 - something important"
        "abcdefg"

    Для строк в языке C не введён специальный тип. Для их хранения используется массив типа char:
        char str[] = "Str1";
    Выше определяется массив str типа char. Ему присваивается строка "Str1".
    Из-за особенностей массивов в C было принято, что последним символом должен обязательно идти
    символ конца строки - '\0'. Таким образом, str представляется в виде массива из 5 символов:
        ['S', 't', 'r', '1', '\0']
    При том, что в исходной строке - всего 4 символа. Для C наличие символа конца строки очень важно,
    все функции обработки строк предполагают, что переданные им массивы будут содержать в себе
    этот символ последним элементом.

    Определение str может быть сделано в явном виде как обычный массив:
        char str[] = {'S', 't', 'r', '1', '\0'};

    При этом, нельзя присваивать строку в двойных кавычках уже объявленным массивам:
        char word[10];
        word = "true"; //Ошибка!

    Для вывода строки на экран можно использовать printf с идентификатором типа - %s
        char word[] = "word";
        printf("%s", word);
    а можно функцию puts:
        puts(word);

    Ввод строки немного более сложен: при использовании scanf + %s нужно не забывать указывать
    максимальное количество считываемых символов:
        char str[30];
        printf("Enter string:\n");
        scanf("%29s", str); // без указания 29 символов для считывания, при вводе 31 и более
                            // символа произойдёт крах программы

    Есть функция gets, которую могли найти в поисковиках, является опасной для использования.

    Другой способ считать строку - считается fgets:
        char sentence[80]; // выделяем 80 символов на предложение

        printf("Enter string:\n");
        fgets(sentence, 80, stdin); // Если введено 80 или больше символов -
                                    // записывает 79 символов в переменную sentence
                                    // и ставит '\0' последним символом
                                    // Если было введено менее 80 символов, то все они помещаются в sentence
                                    // и после последнего символа помещается символ конца строки. Но
                                    // в этом случае в строку попадает и символ переноса строки - '\n'

    Выше указанные функции ввода-вывода опеределены в <stdio.h>

    Также имеется набор функций для работы со строками, определённых в <string.h>.
    Например:
        // Определяем строку, содержащую 32 символа.
        char str[] = "a_long_long_long_word_as_example";
        // Размер массива str в данном случае - 33 символа

        // Функция strlen возращает количество символов в строке
        // без учёта символа конца строки ('\0')
        printf("The size of str is %d", strlen(str)); // будет напечатано: "The size of str is 32"
    Другие примеры - непосредственно в программе.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h> // strlen и другие функции работы со строками

void print_eng_letters(void)
{
    char sym = 'a'; // объявляем переменную типа char и присваиваем ей значение

    printf("English lowercase letters:\n");
    // печатаем все цифры
    while ( sym <= 'z' ) {
        printf("%c ", sym);
        ++sym; // используем операцию инкремента для увеличения кода символа на единицу
               // тоже самое, что и sym += 1
    }
    printf("\n");
}

int main()
{
    print_eng_letters();

    char letter = 'W';
    // Печатаем букву 'W' и её целочисленный код
    printf("The symbol and the code: %c : %d\n", letter, letter);

    // Объявляем и инициализируем строку
    char first_str[] = "A very very important sentence";

    // вычисляем количество элементов в массиве first_str
    unsigned int char_array_size = sizeof(first_str) / sizeof(first_str[0]);
    // Печатаем строку, её длину с помощью функции strlen, и длину массива first_arr
    // Последние два значения будут различаться на единицу.
    // Кому интересно, %u - это печать безнакового (unsigned) целого числа
    printf("The string: %s\nString size: %u\nArray size: %u\n\n", first_str, strlen(first_str), char_array_size);


    /*
        Демонстрация функции strcmp из <string.h>
        Данная функция принимает два аргумента - две строки - и сравнивает из посимвольно.
        Возращает         0    : если все символы совпадают
          значение меньше 0    : если код первого несовпадающего символа в первой строке меньше кода символа во второй строке
          значение больше 0    : если код первого несовпадающего символа в первой строке больше кода символа во второй строке
    */
    char secret_str[] = "just cat"; // задаём строку, при вводе которой будет прерван бесконечный цикл
    char buffer[80];                // массив для хранения введённой пользователем строки
    unsigned short buf_size;        // переменная для вычисления длины введённой строки

    do {
        printf("Guess secret string? "); // просим угадать выше определённую строку
        fgets(buffer, 80, stdin);        // считываем введённую строку

        /*
            Ниже показан трюк, по удалению символа новой строки - '\n' в случае,
            если было введено меньше 79 символов.
        */
        buf_size = strlen(buffer); // вычисляем длину строки
        if ( buffer[buf_size - 1] == '\n') { // проверяем, что перпоследний символ равен '\n'
            buffer[buf_size - 1] = '\0';      // Вместо '\n' ставим '\0', сокращая количство символов в строке на единицу
        }
    } while ( strcmp(secret_str, buffer) != 0 ); // проверяем результат функции сравнения строк
    puts ("Correct answer!\n");

    /*
        Пример функция strcpy и strncat из string.h
    */
    char str1[20], str2[20], str3[] = "or not to be";
    strcpy(str1, "To be ");         // копируем вторую строку в первую. Даже если в str1 были какие-то символы, они замещаются
                                    // символами из второй строки
    strcpy(str2, str3);             // копируем str3 в str2
    strncat(str1, str2, 6);         // добавляем первые 6 символов из str2 в str1
    puts(str1);

    return 0;
}
